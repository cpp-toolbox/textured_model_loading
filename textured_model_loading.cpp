#include <spdlog/spdlog.h>

#include "assimp/Importer.hpp"
#include "assimp/postprocess.h"

#include "textured_model_loading.hpp"
#include "sbpt_generated_includes.hpp"

/**
 * @brief returns a list of lists of the form specified by \ref get_ordered_vertex_positions
 *
 * @return as mentioned in brief
 */
std::vector<std::vector<glm::vec3>> TexturedModel::get_ordered_vertex_positions_for_each_mesh() {
    std::vector<std::vector<glm::vec3>> ovpfem;
    for (auto &mesh : meshes) {
        ovpfem.push_back(get_ordered_vertex_positions(mesh.vertex_positions, mesh.indices));
    }
    return ovpfem;
}

TexturedModel TexturedModelLoader::load_model(const std::string &path) {

    // because we may load multiple models, remember to clear out the old data.
    this->recursively_collected_meshes.clear();

    auto process_step = [this](aiMesh *mesh, const aiScene *scene) {
        this->recursively_collected_meshes.push_back(process_mesh(mesh, scene));
    };

    auto recursively_process_nodes = this->recursively_process_nodes_closure(process_step);

    this->call_function_with_assimp_importer_context(path, [&](auto root, auto scene) {
        spdlog::get(Systems::asset_loading)->info("starting to process nodes");
        recursively_process_nodes(scene->mRootNode, scene);
        spdlog::get(Systems::asset_loading)->info("processed all nodes");
    });

    return {this->recursively_collected_meshes};
};

TexturedMesh TexturedModelLoader::process_mesh(aiMesh *mesh, const aiScene *scene) {
    Mesh processed_mesh = ModelLoader::process_mesh(mesh, scene);
    auto [texture_coordinates, normals] = process_mesh_vertices_texture_info(mesh);
    auto used_textures = process_mesh_materials(mesh, scene);
    return TexturedMesh(processed_mesh.vertex_positions, processed_mesh.indices, texture_coordinates, normals,
                        used_textures);
};

/**
 *
 * /param mesh
 * /return a tuple such that the first component is a list of texture coordinates for each vertex as per the order
 * generated by process_mesh of the base class, normals are in the second component in the same format
 */
std::pair<std::vector<glm::vec2>, std::vector<glm::vec3>>
TexturedModelLoader::process_mesh_vertices_texture_info(aiMesh *mesh) {
    std::vector<glm::vec2> texture_coordinates;
    std::vector<glm::vec3> normals;

    bool mesh_has_texture_coordinates = mesh->mTextureCoords[0] != nullptr;
    for (unsigned int i = 0; i < mesh->mNumVertices; i++) {

        normals.push_back(assimp_to_glm_3d_vector(mesh->mNormals[i]));

        glm::vec2 texture_coordinate;
        if (mesh_has_texture_coordinates) {
            texture_coordinate = glm::vec2(mesh->mTextureCoords[0][i].x, mesh->mTextureCoords[0][i].y);
        } else {
            spdlog::get(Systems::asset_loading)->warn("This mesh doesn't have texture coordinates!");
            texture_coordinate = glm::vec2(0.0f, 0.0f);
        }
        texture_coordinates.push_back(texture_coordinate);
    }
    return {texture_coordinates, normals};
}

std::vector<TextureInfo> TexturedModelLoader::process_mesh_materials(aiMesh *mesh, const aiScene *scene) {
    std::vector<TextureInfo> textures;

    bool mesh_has_materials = mesh->mMaterialIndex >= 0;

    if (mesh_has_materials) {
        aiMaterial *material = scene->mMaterials[mesh->mMaterialIndex];

        std::vector<TextureInfo> diffuse_maps_texture_info =
            get_texture_info_for_material(material, aiTextureType_DIFFUSE, TextureType::DIFFUSE);
        textures.insert(textures.end(), diffuse_maps_texture_info.begin(), diffuse_maps_texture_info.end());

        if (diffuse_maps_texture_info.size() == 0) {
            spdlog::get(Systems::asset_loading)->warn("This material doesn't have any diffuse maps");
        }

        std::vector<TextureInfo> specular_maps_texture_info =
            get_texture_info_for_material(material, aiTextureType_SPECULAR, TextureType::SPECULAR);
        textures.insert(textures.end(), specular_maps_texture_info.begin(), specular_maps_texture_info.end());

        if (specular_maps_texture_info.size() == 0) {
            spdlog::get(Systems::asset_loading)->info("This material doesn't have any specular maps");
        }
    }
    return textures;
}

/**
 * /param material is a collection of all assets required to make a surface have certain lighting effects
 * /param type the type of the texture using assimps enum
 * /param texture_type the type of the texture using our own enum
 * /return
 */
std::vector<TextureInfo> TexturedModelLoader::get_texture_info_for_material(aiMaterial *material, aiTextureType type,
                                                                            TextureType texture_type) {
    std::vector<TextureInfo> textures;
    for (unsigned int i = 0; i < material->GetTextureCount(type); i++) {

        aiString texture_path;
        material->GetTexture(type, i, &texture_path);

        std::string asset_path = directory_to_asset_being_loaded + std::string(texture_path.C_Str());

        TextureInfo texture{texture_type, asset_path.c_str()};
        textures.push_back(texture);
    }
    return textures;
};
